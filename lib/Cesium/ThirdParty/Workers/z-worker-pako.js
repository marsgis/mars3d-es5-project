/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

(function(){"use strict";const V=[];for(let n=0;n<256;n++){let t=n;for(let e=0;e<8;e++)1&t?t=t>>>1^3988292384:t>>>=1;V[n]=t}class S{constructor(t){this.crc=t||-1}append(t){let e=0|this.crc;for(let s=0,r=0|t.length;s<r;s++)e=e>>>8^V[255&(e^t[s])];this.crc=e}get(){return~this.crc}}const p={concat(n,t){if(n.length===0||t.length===0)return n.concat(t);const e=n[n.length-1],s=p.getPartial(e);return s===32?n.concat(t):p._shiftRight(t,s,0|e,n.slice(0,n.length-1))},bitLength(n){const t=n.length;if(t===0)return 0;const e=n[t-1];return 32*(t-1)+p.getPartial(e)},clamp(n,t){if(32*n.length<t)return n;const e=(n=n.slice(0,Math.ceil(t/32))).length;return t&=31,e>0&&t&&(n[e-1]=p.partial(t,n[e-1]&2147483648>>t-1,1)),n},partial:(n,t,e)=>n===32?t:(e?0|t:t<<32-n)+1099511627776*n,getPartial:n=>Math.round(n/1099511627776)||32,_shiftRight(n,t,e,s){for(s===void 0&&(s=[]);t>=32;t-=32)s.push(e),e=0;if(t===0)return s.concat(n);for(let i=0;i<n.length;i++)s.push(e|n[i]>>>t),e=n[i]<<32-t;const r=n.length?n[n.length-1]:0,a=p.getPartial(r);return s.push(p.partial(t+a&31,t+a>32?e:s.pop(),1)),s}},M={bytes:{fromBits(n){const t=p.bitLength(n)/8,e=new Uint8Array(t);let s;for(let r=0;r<t;r++)(3&r)==0&&(s=n[r/4]),e[r]=s>>>24,s<<=8;return e},toBits(n){const t=[];let e,s=0;for(e=0;e<n.length;e++)s=s<<8|n[e],(3&e)==3&&(t.push(s),s=0);return 3&e&&t.push(p.partial(8*(3&e),s)),t}}},j={sha1:function(n){n?(this._h=n._h.slice(0),this._buffer=n._buffer.slice(0),this._length=n._length):this.reset()}};j.sha1.prototype={blockSize:512,reset:function(){const n=this;return n._h=this._init.slice(0),n._buffer=[],n._length=0,n},update:function(n){const t=this;typeof n=="string"&&(n=M.utf8String.toBits(n));const e=t._buffer=p.concat(t._buffer,n),s=t._length,r=t._length=s+p.bitLength(n);if(r>9007199254740991)throw new Error("Cannot hash more than 2^53 - 1 bits");const a=new Uint32Array(e);let i=0;for(let o=t.blockSize+s-(t.blockSize+s&t.blockSize-1);o<=r;o+=t.blockSize)t._block(a.subarray(16*i,16*(i+1))),i+=1;return e.splice(0,16*i),t},finalize:function(){const n=this;let t=n._buffer;const e=n._h;t=p.concat(t,[p.partial(1,1)]);for(let s=t.length+2;15&s;s++)t.push(0);for(t.push(Math.floor(n._length/4294967296)),t.push(0|n._length);t.length;)n._block(t.splice(0,16));return n.reset(),e},_init:[1732584193,4023233417,2562383102,271733878,3285377520],_key:[1518500249,1859775393,2400959708,3395469782],_f:function(n,t,e,s){return n<=19?t&e|~t&s:n<=39?t^e^s:n<=59?t&e|t&s|e&s:n<=79?t^e^s:void 0},_S:function(n,t){return t<<n|t>>>32-n},_block:function(n){const t=this,e=t._h,s=Array(80);for(let c=0;c<16;c++)s[c]=n[c];let r=e[0],a=e[1],i=e[2],o=e[3],h=e[4];for(let c=0;c<=79;c++){c>=16&&(s[c]=t._S(1,s[c-3]^s[c-8]^s[c-14]^s[c-16]));const l=t._S(5,r)+t._f(c,a,i,o)+h+s[c]+t._key[Math.floor(c/20)]|0;h=o,o=i,i=t._S(30,a),a=r,r=l}e[0]=e[0]+r|0,e[1]=e[1]+a|0,e[2]=e[2]+i|0,e[3]=e[3]+o|0,e[4]=e[4]+h|0}};const $={aes:class{constructor(n){const t=this;t._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],t._tables[0][0][0]||t._precompute();const e=t._tables[0][4],s=t._tables[1],r=n.length;let a,i,o,h=1;if(r!==4&&r!==6&&r!==8)throw new Error("invalid aes key size");for(t._key=[i=n.slice(0),o=[]],a=r;a<4*r+28;a++){let c=i[a-1];(a%r==0||r===8&&a%r==4)&&(c=e[c>>>24]<<24^e[c>>16&255]<<16^e[c>>8&255]<<8^e[255&c],a%r==0&&(c=c<<8^c>>>24^h<<24,h=h<<1^283*(h>>7))),i[a]=i[a-r]^c}for(let c=0;a;c++,a--){const l=i[3&c?a:a-4];o[c]=a<=4||c<4?l:s[0][e[l>>>24]]^s[1][e[l>>16&255]]^s[2][e[l>>8&255]]^s[3][e[255&l]]}}encrypt(n){return this._crypt(n,0)}decrypt(n){return this._crypt(n,1)}_precompute(){const n=this._tables[0],t=this._tables[1],e=n[4],s=t[4],r=[],a=[];let i,o,h,c;for(let l=0;l<256;l++)a[(r[l]=l<<1^283*(l>>7))^l]=l;for(let l=i=0;!e[l];l^=o||1,i=a[i]||1){let d=i^i<<1^i<<2^i<<3^i<<4;d=d>>8^255&d^99,e[l]=d,s[d]=l,c=r[h=r[o=r[l]]];let A=16843009*c^65537*h^257*o^16843008*l,U=257*r[d]^16843008*d;for(let f=0;f<4;f++)n[f][l]=U=U<<24^U>>>8,t[f][d]=A=A<<24^A>>>8}for(let l=0;l<5;l++)n[l]=n[l].slice(0),t[l]=t[l].slice(0)}_crypt(n,t){if(n.length!==4)throw new Error("invalid aes block size");const e=this._key[t],s=e.length/4-2,r=[0,0,0,0],a=this._tables[t],i=a[0],o=a[1],h=a[2],c=a[3],l=a[4];let d,A,U,f=n[0]^e[0],w=n[t?3:1]^e[1],_=n[2]^e[2],b=n[t?1:3]^e[3],z=4;for(let m=0;m<s;m++)d=i[f>>>24]^o[w>>16&255]^h[_>>8&255]^c[255&b]^e[z],A=i[w>>>24]^o[_>>16&255]^h[b>>8&255]^c[255&f]^e[z+1],U=i[_>>>24]^o[b>>16&255]^h[f>>8&255]^c[255&w]^e[z+2],b=i[b>>>24]^o[f>>16&255]^h[w>>8&255]^c[255&_]^e[z+3],z+=4,f=d,w=A,_=U;for(let m=0;m<4;m++)r[t?3&-m:m]=l[f>>>24]<<24^l[w>>16&255]<<16^l[_>>8&255]<<8^l[255&b]^e[z++],d=f,f=w,w=_,_=b,b=d;return r}}},tt={ctrGladman:class{constructor(n,t){this._prf=n,this._initIv=t,this._iv=t}reset(){this._iv=this._initIv}update(n){return this.calculate(this._prf,n,this._iv)}incWord(n){if((n>>24&255)==255){let t=n>>16&255,e=n>>8&255,s=255&n;t===255?(t=0,e===255?(e=0,s===255?s=0:++s):++e):++t,n=0,n+=t<<16,n+=e<<8,n+=s}else n+=1<<24;return n}incCounter(n){(n[0]=this.incWord(n[0]))===0&&(n[1]=this.incWord(n[1]))}calculate(n,t,e){let s;if(!(s=t.length))return[];const r=p.bitLength(t);for(let a=0;a<s;a+=4){this.incCounter(e);const i=n.encrypt(e);t[a]^=i[0],t[a+1]^=i[1],t[a+2]^=i[2],t[a+3]^=i[3]}return p.clamp(t,r)}}},et={hmacSha1:class{constructor(n){const t=this,e=t._hash=j.sha1,s=[[],[]],r=e.prototype.blockSize/32;t._baseHash=[new e,new e],n.length>r&&(n=e.hash(n));for(let a=0;a<r;a++)s[0][a]=909522486^n[a],s[1][a]=1549556828^n[a];t._baseHash[0].update(s[0]),t._baseHash[1].update(s[1]),t._resultHash=new e(t._baseHash[0])}reset(){const n=this;n._resultHash=new n._hash(n._baseHash[0]),n._updated=!1}update(n){this._updated=!0,this._resultHash.update(n)}digest(){const n=this,t=n._resultHash.finalize(),e=new n._hash(n._baseHash[1]).update(t).finalize();return n.reset(),e}}},O="Invalid pasword",k=16,E={name:"PBKDF2"},nt=Object.assign({hash:{name:"HMAC"}},E),st=Object.assign({iterations:1e3,hash:{name:"SHA-1"}},E),rt=["deriveBits"],v=[8,12,16],C=[16,24,32],y=10,K=[0,0,0,0],g=M.bytes,G=$.aes,W=tt.ctrGladman,L=et.hmacSha1;class at{constructor(t,e,s){Object.assign(this,{password:t,signed:e,strength:s-1,pendingInput:new Uint8Array(0)})}async append(t){const e=this;if(e.password){const s=u(t,0,v[e.strength]+2);await async function(r,a,i){await T(r,i,u(a,0,v[r.strength]));const o=u(a,v[r.strength]),h=r.keys.passwordVerification;if(h[0]!=o[0]||h[1]!=o[1])throw new Error(O)}(e,s,e.password),e.password=null,e.aesCtrGladman=new W(new G(e.keys.key),Array.from(K)),e.hmac=new L(e.keys.authentication),t=u(t,v[e.strength]+2)}return P(e,t,new Uint8Array(t.length-y-(t.length-y)%k),0,y,!0)}flush(){const t=this,e=t.pendingInput,s=u(e,0,e.length-y),r=u(e,e.length-y);let a=new Uint8Array(0);if(s.length){const o=g.toBits(s);t.hmac.update(o);const h=t.aesCtrGladman.update(o);a=g.fromBits(h)}let i=!0;if(t.signed){const o=u(g.fromBits(t.hmac.digest()),0,y);for(let h=0;h<y;h++)o[h]!=r[h]&&(i=!1)}return{valid:i,data:a}}}class it{constructor(t,e){Object.assign(this,{password:t,strength:e-1,pendingInput:new Uint8Array(0)})}async append(t){const e=this;let s=new Uint8Array(0);e.password&&(s=await async function(a,i){const o=crypto.getRandomValues(new Uint8Array(v[a.strength]));return await T(a,i,o),D(o,a.keys.passwordVerification)}(e,e.password),e.password=null,e.aesCtrGladman=new W(new G(e.keys.key),Array.from(K)),e.hmac=new L(e.keys.authentication));const r=new Uint8Array(s.length+t.length-t.length%k);return r.set(s,0),P(e,t,r,s.length,0)}flush(){const t=this;let e=new Uint8Array(0);if(t.pendingInput.length){const r=t.aesCtrGladman.update(g.toBits(t.pendingInput));t.hmac.update(r),e=g.fromBits(r)}const s=u(g.fromBits(t.hmac.digest()),0,y);return{data:D(e,s),signature:s}}}function P(n,t,e,s,r,a){const i=t.length-r;let o;for(n.pendingInput.length&&(t=D(n.pendingInput,t),e=function(h,c){if(c&&c>h.length){const l=h;(h=new Uint8Array(c)).set(l,0)}return h}(e,i-i%k)),o=0;o<=i-k;o+=k){const h=g.toBits(u(t,o,o+k));a&&n.hmac.update(h);const c=n.aesCtrGladman.update(h);a||n.hmac.update(c),e.set(g.fromBits(c),o+s)}return n.pendingInput=u(t,o),e}async function T(n,t,e){const s=new TextEncoder().encode(t),r=await crypto.subtle.importKey("raw",s,nt,!1,rt),a=await crypto.subtle.deriveBits(Object.assign({salt:e},st),r,8*(2*C[n.strength]+2)),i=new Uint8Array(a);n.keys={key:g.toBits(u(i,0,C[n.strength])),authentication:g.toBits(u(i,C[n.strength],2*C[n.strength])),passwordVerification:u(i,2*C[n.strength])}}function D(n,t){let e=n;return n.length+t.length&&(e=new Uint8Array(n.length+t.length),e.set(n,0),e.set(t,n.length)),e}function u(n,t,e){return n.subarray(t,e)}const B=12;class ct{constructor(t,e){Object.assign(this,{password:t,passwordVerification:e}),F(this,t)}append(t){const e=this;if(e.password){const s=R(e,t.subarray(0,B));if(e.password=null,s[11]!=e.passwordVerification)throw new Error(O);t=t.subarray(B)}return R(e,t)}flush(){return{valid:!0,data:new Uint8Array(0)}}}class ot{constructor(t,e){Object.assign(this,{password:t,passwordVerification:e}),F(this,t)}append(t){const e=this;let s,r;if(e.password){e.password=null;const a=crypto.getRandomValues(new Uint8Array(B));a[11]=e.passwordVerification,s=new Uint8Array(t.length+a.length),s.set(x(e,a),0),r=B}else s=new Uint8Array(t.length),r=0;return s.set(x(e,t),r),s}flush(){return{data:new Uint8Array(0)}}}function R(n,t){const e=new Uint8Array(t.length);for(let s=0;s<t.length;s++)e[s]=q(n)^t[s],I(n,e[s]);return e}function x(n,t){const e=new Uint8Array(t.length);for(let s=0;s<t.length;s++)e[s]=q(n)^t[s],I(n,t[s]);return e}function F(n,t){n.keys=[305419896,591751049,878082192],n.crcKey0=new S(n.keys[0]),n.crcKey2=new S(n.keys[2]);for(let e=0;e<t.length;e++)I(n,t.charCodeAt(e))}function I(n,t){n.crcKey0.append([t]),n.keys[0]=~n.crcKey0.get(),n.keys[1]=N(n.keys[1]+J(n.keys[0])),n.keys[1]=N(Math.imul(n.keys[1],134775813)+1),n.crcKey2.append([n.keys[1]>>>24]),n.keys[2]=~n.crcKey2.get()}function q(n){const t=2|n.keys[2];return J(Math.imul(t,1^t)>>>8)}function J(n){return 255&n}function N(n){return 4294967295&n}const Q="deflate",X="inflate",Y="Invalid signature";class lt{constructor(t,{signature:e,password:s,signed:r,compressed:a,zipCrypto:i,passwordVerification:o,encryptionStrength:h},{chunkSize:c}){const l=Boolean(s);Object.assign(this,{signature:e,encrypted:l,signed:r,compressed:a,inflate:a&&new t({chunkSize:c}),crc32:r&&new S,zipCrypto:i,decrypt:l&&i?new ct(s,o):new at(s,r,h)})}async append(t){const e=this;return e.encrypted&&t.length&&(t=await e.decrypt.append(t)),e.compressed&&t.length&&(t=await e.inflate.append(t)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),t}async flush(){const t=this;let e,s=new Uint8Array(0);if(t.encrypted){const r=t.decrypt.flush();if(!r.valid)throw new Error(Y);s=r.data}if((!t.encrypted||t.zipCrypto)&&t.signed){const r=new DataView(new Uint8Array(4).buffer);if(e=t.crc32.get(),r.setUint32(0,e),t.signature!=r.getUint32(0,!1))throw new Error(Y)}return t.compressed&&(s=await t.inflate.append(s)||new Uint8Array(0),await t.inflate.flush()),{data:s,signature:e}}}class ht{constructor(t,{encrypted:e,signed:s,compressed:r,level:a,zipCrypto:i,password:o,passwordVerification:h,encryptionStrength:c},{chunkSize:l}){Object.assign(this,{encrypted:e,signed:s,compressed:r,deflate:r&&new t({level:a||5,chunkSize:l}),crc32:s&&new S,zipCrypto:i,encrypt:e&&i?new ot(o,h):new it(o,c)})}async append(t){const e=this;let s=t;return e.compressed&&t.length&&(s=await e.deflate.append(t)),e.encrypted&&s.length&&(s=await e.encrypt.append(s)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),s}async flush(){const t=this;let e,s=new Uint8Array(0);if(t.compressed&&(s=await t.deflate.flush()||new Uint8Array(0)),t.encrypted){s=await t.encrypt.append(s);const r=t.encrypt.flush();e=r.signature;const a=new Uint8Array(s.length+r.data.length);a.set(s,0),a.set(r.data,s.length),s=a}return t.encrypted&&!t.zipCrypto||!t.signed||(e=t.crc32.get()),{data:s,signature:e}}}const pt={init(n){n.scripts&&n.scripts.length&&importScripts.apply(void 0,n.scripts);const t=n.options;let e;self.initCodec&&self.initCodec(),t.codecType.startsWith(Q)?e=self.Deflate:t.codecType.startsWith(X)&&(e=self.Inflate),H=function(s,r,a){return r.codecType.startsWith(Q)?new ht(s,r,a):r.codecType.startsWith(X)?new lt(s,r,a):void 0}(e,t,n.config)},append:async n=>({data:await H.append(n.data)}),flush:()=>H.flush()};let H;addEventListener("message",async n=>{const t=n.data,e=t.type,s=pt[e];if(s)try{t.data&&(t.data=new Uint8Array(t.data));const r=await s(t)||{};if(r.type=e,r.data)try{r.data=r.data.buffer,postMessage(r,[r.data])}catch{postMessage(r)}else postMessage(r)}catch(r){postMessage({type:e,error:{message:r.message,stack:r.stack}})}});function Z(n,t,e){return class{constructor(r){const a=this;a.codec=new n(Object.assign({},t,r)),e(a.codec,i=>{if(a.pendingData){const o=a.pendingData;a.pendingData=new Uint8Array(o.length+i.length),a.pendingData.set(o,0),a.pendingData.set(i,o.length)}else a.pendingData=new Uint8Array(i)})}async append(r){return this.codec.push(r),s(this)}async flush(){return this.codec.push(new Uint8Array(0),!0),s(this)}};function s(r){if(r.pendingData){const a=r.pendingData;return r.pendingData=null,a}return new Uint8Array(0)}}self.initCodec=()=>{const{Deflate:n,Inflate:t}=((e,s={},r)=>({Deflate:Z(e.Deflate,s.deflate,r),Inflate:Z(e.Inflate,s.inflate,r)}))(pako,{deflate:{raw:!0},inflate:{raw:!0}},(e,s)=>e.onData=s);self.Deflate=n,self.Inflate=t}})();
