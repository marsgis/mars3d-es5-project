define(["./AttributeCompression-6b1e8028","./Matrix2-d1511f33","./Color-f5eecef5","./when-229515d6","./IndexDatatype-c2b69fc2","./ComponentDatatype-5f63ec93","./OrientedBoundingBox-9ee6ad06","./createTaskProcessorWorker","./RuntimeError-8f3d96ee","./Transforms-46cc38bd","./combine-6d9c3903","./WebGLConstants-f63312fc","./EllipsoidTangentPlane-7095b5e7","./AxisAlignedBoundingBox-b31bb45f","./IntersectionTests-65655905","./Plane-1217b5b0"],(function(e,t,n,r,a,o,i,s,c,f,d,l,u,h,g,p){"use strict";const b=new t.Cartesian3,m=new t.Ellipsoid,y=new t.Rectangle,C={min:void 0,max:void 0,indexBytesPerElement:void 0};function I(e,t,r){const a=t.length,o=2+a*i.OrientedBoundingBox.packedLength+1+function(e){const t=e.length;let r=0;for(let a=0;a<t;++a)r+=n.Color.packedLength+3+e[a].batchIds.length;return r}(r),s=new Float64Array(o);let c=0;s[c++]=e,s[c++]=a;for(let e=0;e<a;++e)i.OrientedBoundingBox.pack(t[e],s,c),c+=i.OrientedBoundingBox.packedLength;const f=r.length;s[c++]=f;for(let e=0;e<f;++e){const t=r[e];n.Color.pack(t.color,s,c),c+=n.Color.packedLength,s[c++]=t.offset,s[c++]=t.count;const a=t.batchIds,o=a.length;s[c++]=o;for(let e=0;e<o;++e)s[c++]=a[e]}return s}const w=new t.Cartesian3,x=new t.Cartesian3,A=new t.Cartesian3,E=new t.Cartesian3,N=new t.Cartesian3,T=new t.Cartographic,B=new t.Rectangle;return s((function(s,c){let f;!function(e){const n=new Float64Array(e);let r=0;C.indexBytesPerElement=n[r++],C.min=n[r++],C.max=n[r++],t.Cartesian3.unpack(n,r,b),r+=t.Cartesian3.packedLength,t.Ellipsoid.unpack(n,r,m),r+=t.Ellipsoid.packedLength,t.Rectangle.unpack(n,r,y)}(s.packedBuffer),f=2===C.indexBytesPerElement?new Uint16Array(s.indices):new Uint32Array(s.indices);const d=new Uint16Array(s.positions),l=new Uint32Array(s.counts),u=new Uint32Array(s.indexCounts),h=new Uint32Array(s.batchIds),g=new Uint32Array(s.batchTableColors),p=new Array(l.length),k=b,L=m;let O=y;const U=C.min,P=C.max;let F,S,D,R=s.minimumHeights,M=s.maximumHeights;r.defined(R)&&r.defined(M)&&(R=new Float32Array(R),M=new Float32Array(M));const _=d.length/2,G=d.subarray(0,_),Y=d.subarray(_,2*_);e.AttributeCompression.zigZagDeltaDecode(G,Y);const V=new Float64Array(3*_);for(F=0;F<_;++F){const e=G[F],n=Y[F],r=o.CesiumMath.lerp(O.west,O.east,e/32767),a=o.CesiumMath.lerp(O.south,O.north,n/32767),i=t.Cartographic.fromRadians(r,a,0,T),s=L.cartographicToCartesian(i,w);t.Cartesian3.pack(s,V,3*F)}const v=l.length,H=new Array(v),W=new Array(v);let z=0,Z=0;for(F=0;F<v;++F)H[F]=z,W[F]=Z,z+=l[F],Z+=u[F];const j=new Float32Array(3*_*2),q=new Uint16Array(2*_),J=new Uint32Array(W.length),K=new Uint32Array(u.length);let Q=[];const X={};for(F=0;F<v;++F)D=g[F],r.defined(X[D])?(X[D].positionLength+=l[F],X[D].indexLength+=u[F],X[D].batchIds.push(F)):X[D]={positionLength:l[F],indexLength:u[F],offset:0,indexOffset:0,batchIds:[F]};let $,ee=0,te=0;for(D in X)if(X.hasOwnProperty(D)){$=X[D],$.offset=ee,$.indexOffset=te;const e=2*$.positionLength,t=2*$.indexLength+6*$.positionLength;ee+=e,te+=t,$.indexLength=t}const ne=[];for(D in X)X.hasOwnProperty(D)&&($=X[D],ne.push({color:n.Color.fromRgba(parseInt(D)),offset:$.indexOffset,count:$.indexLength,batchIds:$.batchIds}));for(F=0;F<v;++F){D=g[F],$=X[D];const e=$.offset;let n=3*e,a=e;const o=H[F],s=l[F],c=h[F];let d=U,b=P;r.defined(R)&&r.defined(M)&&(d=R[F],b=M[F]);let m=Number.POSITIVE_INFINITY,y=Number.NEGATIVE_INFINITY,C=Number.POSITIVE_INFINITY,I=Number.NEGATIVE_INFINITY;for(S=0;S<s;++S){const e=t.Cartesian3.unpack(V,3*o+3*S,w);L.scaleToGeodeticSurface(e,e);const r=L.cartesianToCartographic(e,T),i=r.latitude,s=r.longitude;m=Math.min(i,m),y=Math.max(i,y),C=Math.min(s,C),I=Math.max(s,I);const f=L.geodeticSurfaceNormal(e,x);let l=t.Cartesian3.multiplyByScalar(f,d,A);const u=t.Cartesian3.add(e,l,E);l=t.Cartesian3.multiplyByScalar(f,b,l);const h=t.Cartesian3.add(e,l,N);t.Cartesian3.subtract(h,k,h),t.Cartesian3.subtract(u,k,u),t.Cartesian3.pack(h,j,n),t.Cartesian3.pack(u,j,n+3),q[a]=c,q[a+1]=c,n+=6,a+=2}O=B,O.west=C,O.east=I,O.south=m,O.north=y,p[F]=i.OrientedBoundingBox.fromRectangle(O,U,P,L);let _=$.indexOffset;const G=W[F],Y=u[F];for(J[F]=_,S=0;S<Y;S+=3){const t=f[G+S]-o,n=f[G+S+1]-o,r=f[G+S+2]-o;Q[_++]=2*t+e,Q[_++]=2*n+e,Q[_++]=2*r+e,Q[_++]=2*r+1+e,Q[_++]=2*n+1+e,Q[_++]=2*t+1+e}for(S=0;S<s;++S){const t=S,n=(S+1)%s;Q[_++]=2*t+1+e,Q[_++]=2*n+e,Q[_++]=2*t+e,Q[_++]=2*t+1+e,Q[_++]=2*n+1+e,Q[_++]=2*n+e}$.offset+=2*s,$.indexOffset=_,K[F]=_-J[F]}Q=a.IndexDatatype.createTypedArray(j.length/3,Q);const re=ne.length;for(let e=0;e<re;++e){const t=ne[e].batchIds;let n=0;const r=t.length;for(let e=0;e<r;++e)n+=K[t[e]];ne[e].count=n}const ae=I(2===Q.BYTES_PER_ELEMENT?a.IndexDatatype.UNSIGNED_SHORT:a.IndexDatatype.UNSIGNED_INT,p,ne);return c.push(j.buffer,Q.buffer,J.buffer,K.buffer,q.buffer,ae.buffer),{positions:j.buffer,indices:Q.buffer,indexOffsets:J.buffer,indexCounts:K.buffer,batchIds:q.buffer,packedBuffer:ae.buffer}}))}));
