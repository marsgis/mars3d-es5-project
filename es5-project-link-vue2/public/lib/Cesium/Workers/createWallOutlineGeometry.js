define(["./when-229515d6","./Matrix2-d1511f33","./Transforms-46cc38bd","./ComponentDatatype-5f63ec93","./RuntimeError-8f3d96ee","./GeometryAttribute-727885bb","./GeometryAttributes-b253752a","./IndexDatatype-c2b69fc2","./WallGeometryLibrary-03faef07","./combine-6d9c3903","./WebGLConstants-f63312fc","./arrayRemoveDuplicates-7cd4e18c","./PolylinePipeline-d2c6257d","./EllipsoidGeodesic-e91747c0","./EllipsoidRhumbLine-15aed367","./IntersectionTests-65655905","./Plane-1217b5b0"],(function(e,i,t,n,o,s,a,r,l,m,d,u,c,p,f,h,g){"use strict";const y=new i.Cartesian3,_=new i.Cartesian3;function E(t){const o=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions,s=t.maximumHeights,a=t.minimumHeights,r=e.defaultValue(t.granularity,n.CesiumMath.RADIANS_PER_DEGREE),l=e.defaultValue(t.ellipsoid,i.Ellipsoid.WGS84);this._positions=o,this._minimumHeights=a,this._maximumHeights=s,this._granularity=r,this._ellipsoid=i.Ellipsoid.clone(l),this._workerName="createWallOutlineGeometry";let m=1+o.length*i.Cartesian3.packedLength+2;e.defined(a)&&(m+=a.length),e.defined(s)&&(m+=s.length),this.packedLength=m+i.Ellipsoid.packedLength+1}E.pack=function(t,n,o){let s;o=e.defaultValue(o,0);const a=t._positions;let r=a.length;for(n[o++]=r,s=0;s<r;++s,o+=i.Cartesian3.packedLength)i.Cartesian3.pack(a[s],n,o);const l=t._minimumHeights;if(r=e.defined(l)?l.length:0,n[o++]=r,e.defined(l))for(s=0;s<r;++s)n[o++]=l[s];const m=t._maximumHeights;if(r=e.defined(m)?m.length:0,n[o++]=r,e.defined(m))for(s=0;s<r;++s)n[o++]=m[s];return i.Ellipsoid.pack(t._ellipsoid,n,o),n[o+=i.Ellipsoid.packedLength]=t._granularity,n};const b=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),C={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:b,granularity:void 0};return E.unpack=function(t,n,o){let s;n=e.defaultValue(n,0);let a=t[n++];const r=new Array(a);for(s=0;s<a;++s,n+=i.Cartesian3.packedLength)r[s]=i.Cartesian3.unpack(t,n);let l,m;if(a=t[n++],a>0)for(l=new Array(a),s=0;s<a;++s)l[s]=t[n++];if(a=t[n++],a>0)for(m=new Array(a),s=0;s<a;++s)m[s]=t[n++];const d=i.Ellipsoid.unpack(t,n,b),u=t[n+=i.Ellipsoid.packedLength];return e.defined(o)?(o._positions=r,o._minimumHeights=l,o._maximumHeights=m,o._ellipsoid=i.Ellipsoid.clone(d,o._ellipsoid),o._granularity=u,o):(C.positions=r,C.minimumHeights=l,C.maximumHeights=m,C.granularity=u,new E(C))},E.fromConstantHeights=function(i){const t=(i=e.defaultValue(i,e.defaultValue.EMPTY_OBJECT)).positions;let n,o;const s=i.minimumHeight,a=i.maximumHeight,r=e.defined(s),l=e.defined(a);if(r||l){const e=t.length;n=r?new Array(e):void 0,o=l?new Array(e):void 0;for(let i=0;i<e;++i)r&&(n[i]=s),l&&(o[i]=a)}return new E({positions:t,maximumHeights:o,minimumHeights:n,ellipsoid:i.ellipsoid})},E.createGeometry=function(o){const m=o._positions,d=o._minimumHeights,u=o._maximumHeights,c=o._granularity,p=o._ellipsoid,f=l.WallGeometryLibrary.computePositions(p,m,u,d,c,!1);if(!e.defined(f))return;const h=f.bottomPositions,g=f.topPositions;let E=g.length,b=2*E;const C=new Float64Array(b);let H,A=0;for(E/=3,H=0;H<E;++H){const e=3*H,t=i.Cartesian3.fromArray(g,e,y),n=i.Cartesian3.fromArray(h,e,_);C[A++]=n.x,C[A++]=n.y,C[A++]=n.z,C[A++]=t.x,C[A++]=t.y,C[A++]=t.z}const w=new a.GeometryAttributes({position:new s.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:C})}),k=b/3;b=2*k-4+k;const x=r.IndexDatatype.createTypedArray(k,b);let G=0;for(H=0;H<k-2;H+=2){const e=H,t=H+2,o=i.Cartesian3.fromArray(C,3*e,y),s=i.Cartesian3.fromArray(C,3*t,_);if(i.Cartesian3.equalsEpsilon(o,s,n.CesiumMath.EPSILON10))continue;const a=H+1,r=H+3;x[G++]=a,x[G++]=e,x[G++]=a,x[G++]=r,x[G++]=e,x[G++]=t}return x[G++]=k-2,x[G++]=k-1,new s.Geometry({attributes:w,indices:x,primitiveType:s.PrimitiveType.LINES,boundingSphere:new t.BoundingSphere.fromVertices(C)})},function(t,n){return e.defined(n)&&(t=E.unpack(t,n)),t._ellipsoid=i.Ellipsoid.clone(t._ellipsoid),E.createGeometry(t)}}));
