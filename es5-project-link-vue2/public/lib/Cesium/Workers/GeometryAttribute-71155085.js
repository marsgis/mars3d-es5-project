define(["exports","./Matrix2-1509208a","./RuntimeError-ac440aa5","./defaultValue-69ee94f4","./WebGLConstants-f63312fc","./Transforms-bf323bcf"],(function(t,e,a,n,r,i){"use strict";var o=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3});const s={POINTS:r.WebGLConstants.POINTS,LINES:r.WebGLConstants.LINES,LINE_LOOP:r.WebGLConstants.LINE_LOOP,LINE_STRIP:r.WebGLConstants.LINE_STRIP,TRIANGLES:r.WebGLConstants.TRIANGLES,TRIANGLE_STRIP:r.WebGLConstants.TRIANGLE_STRIP,TRIANGLE_FAN:r.WebGLConstants.TRIANGLE_FAN,validate:function(t){return t===s.POINTS||t===s.LINES||t===s.LINE_LOOP||t===s.LINE_STRIP||t===s.TRIANGLES||t===s.TRIANGLE_STRIP||t===s.TRIANGLE_FAN}};var u=Object.freeze(s);function I(t){t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=n.defaultValue(t.primitiveType,u.TRIANGLES),this.boundingSphere=t.boundingSphere,this.geometryType=n.defaultValue(t.geometryType,o.NONE),this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}I.computeNumberOfVertices=function(t){let e=-1;for(const a in t.attributes)if(t.attributes.hasOwnProperty(a)&&n.defined(t.attributes[a])&&n.defined(t.attributes[a].values)){const n=t.attributes[a];e=n.values.length/n.componentsPerAttribute}return e};const N=new e.Cartographic,c=new e.Cartesian3,l=new e.Matrix4,T=[new e.Cartographic,new e.Cartographic,new e.Cartographic],f=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],m=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],p=new e.Cartesian3,y=new i.Quaternion,E=new e.Matrix4,b=new e.Matrix2;I._textureCoordinateRotationPoints=function(t,a,n,r){let o;const s=e.Rectangle.center(r,N),u=e.Cartographic.toCartesian(s,n,c),I=i.Transforms.eastNorthUpToFixedFrame(u,n,l),L=e.Matrix4.inverse(I,l),C=f,h=T;h[0].longitude=r.west,h[0].latitude=r.south,h[1].longitude=r.west,h[1].latitude=r.north,h[2].longitude=r.east,h[2].latitude=r.south;let x=p;for(o=0;o<3;o++)e.Cartographic.toCartesian(h[o],n,x),x=e.Matrix4.multiplyByPointAsVector(L,x,x),C[o].x=x.x,C[o].y=x.y;const d=i.Quaternion.fromAxisAngle(e.Cartesian3.UNIT_Z,-a,y),A=e.Matrix3.fromQuaternion(d,E),P=t.length;let S=Number.POSITIVE_INFINITY,G=Number.POSITIVE_INFINITY,R=Number.NEGATIVE_INFINITY,w=Number.NEGATIVE_INFINITY;for(o=0;o<P;o++)x=e.Matrix4.multiplyByPointAsVector(L,t[o],x),x=e.Matrix3.multiplyByVector(A,x,x),S=Math.min(S,x.x),G=Math.min(G,x.y),R=Math.max(R,x.x),w=Math.max(w,x.y);const O=e.Matrix2.fromRotation(a,b),_=m;_[0].x=S,_[0].y=G,_[1].x=S,_[1].y=w,_[2].x=R,_[2].y=G;const g=C[0],V=C[2].x-g.x,M=C[1].y-g.y;for(o=0;o<3;o++){const t=_[o];e.Matrix2.multiplyByVector(O,t,t),t.x=(t.x-g.x)/V,t.y=(t.y-g.y)/M}const v=_[0],F=_[1],W=_[2],Y=new Array(6);return e.Cartesian2.pack(v,Y),e.Cartesian2.pack(F,Y,2),e.Cartesian2.pack(W,Y,4),Y},t.Geometry=I,t.GeometryAttribute=function(t){t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT),this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=n.defaultValue(t.normalize,!1),this.values=t.values},t.GeometryType=o,t.PrimitiveType=u}));
